{"ast":null,"code":"var common = exports,\n    url = require('url'),\n    extend = require('util')._extend,\n    required = require('requires-port');\n\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n    isSSL = /^https|wss/;\n/**\r\n * Simple Regex for testing if protocol is https\r\n */\n\ncommon.isSSL = isSSL;\n/**\r\n * Copies the right headers from `options` and `req` to\r\n * `outgoing` which is then used to fire the proxied\r\n * request.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupOutgoing(outgoing, options, req)\r\n *    // => { host: ..., hostname: ...}\r\n *\r\n * @param {Object} Outgoing Base object to be filled with required properties\r\n * @param {Object} Options Config object passed to the proxy\r\n * @param {ClientRequest} Req Request Object\r\n * @param {String} Forward String to select forward or target\r\n * \r\n * @return {Object} Outgoing Object with all required properties set\r\n *\r\n * @api private\r\n */\n\ncommon.setupOutgoing = function (outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port || (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n  ['host', 'hostname', 'socketPath', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(function (e) {\n    outgoing[e] = options[forward || 'target'][e];\n  });\n  outgoing.method = options.method || req.method;\n  outgoing.headers = extend({}, req.headers);\n\n  if (options.headers) {\n    extend(outgoing.headers, options.headers);\n  }\n\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n\n  if (options.ca) {\n    outgoing.ca = options.ca;\n  }\n\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = typeof options.secure === \"undefined\" ? true : options.secure;\n  }\n\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress; //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n\n    if (typeof outgoing.headers.connection !== 'string' || !upgradeHeader.test(outgoing.headers.connection)) {\n      outgoing.headers.connection = 'close';\n    }\n  } // the final path is target path + relative path requested by user:\n\n\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false ? target.path || '' : ''; //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n\n  var outgoingPath = !options.toProxy ? url.parse(req.url).path || '' : req.url; //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n\n  if (options.changeOrigin) {\n    outgoing.headers.host = required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host) ? outgoing.host + ':' + outgoing.port : outgoing.host;\n  }\n\n  return outgoing;\n};\n/**\r\n * Set the proper configuration for sockets,\r\n * set no delay and set keep alive, also set\r\n * the timeout to 0.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupSocket(socket)\r\n *    // => Socket\r\n *\r\n * @param {Socket} Socket instance to setup\r\n * \r\n * @return {Socket} Return the configured socket.\r\n *\r\n * @api private\r\n */\n\n\ncommon.setupSocket = function (socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  socket.setKeepAlive(true, 0);\n  return socket;\n};\n/**\r\n * Get the port number from the host. Or guess it based on the connection type.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {String} The port number.\r\n *\r\n * @api private\r\n */\n\n\ncommon.getPort = function (req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n  return res ? res[1] : common.hasEncryptedConnection(req) ? '443' : '80';\n};\n/**\r\n * Check if the request has an encrypted connection.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {Boolean} Whether the connection is encrypted or not.\r\n *\r\n * @api private\r\n */\n\n\ncommon.hasEncryptedConnection = function (req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n/**\r\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\r\n *\r\n * @return {String} The generated path.\r\n *\r\n * @api private\r\n */\n\n\ncommon.urlJoin = function () {\n  //\n  // We do not want to mess with the query string. All we want to touch is the path.\n  //\n  var args = Array.prototype.slice.call(arguments),\n      lastIndex = args.length - 1,\n      last = args[lastIndex],\n      lastSegs = last.split('?'),\n      retSegs;\n  args[lastIndex] = lastSegs.shift(); //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n\n  retSegs = [args.filter(Boolean).join('/').replace(/\\/+/g, '/').replace('http:/', 'http://').replace('https:/', 'https://')]; // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n  // Handle case where there could be multiple ? in the URL.\n\n  retSegs.push.apply(retSegs, lastSegs);\n  return retSegs.join('?');\n};\n/**\r\n * Rewrites or removes the domain of a cookie header\r\n *\r\n * @param {String|Array} Header\r\n * @param {Object} Config, mapping of domain to rewritten domain.\r\n *                 '*' key to match any domain, null value to remove the domain.\r\n *\r\n * @api private\r\n */\n\n\ncommon.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {\n  if (Array.isArray(header)) {\n    return header.map(function (headerElement) {\n      return rewriteCookieProperty(headerElement, config, property);\n    });\n  }\n\n  return header.replace(new RegExp(\"(;\\\\s*\" + property + \"=)([^;]+)\", 'i'), function (match, prefix, previousValue) {\n    var newValue;\n\n    if (previousValue in config) {\n      newValue = config[previousValue];\n    } else if ('*' in config) {\n      newValue = config['*'];\n    } else {\n      //no match, return previous value\n      return match;\n    }\n\n    if (newValue) {\n      //replace value\n      return prefix + newValue;\n    } else {\n      //remove value\n      return '';\n    }\n  });\n};\n/**\r\n * Check the host and see if it potentially has a port in it (keep it simple)\r\n *\r\n * @returns {Boolean} Whether we have one or not\r\n *\r\n * @api private\r\n */\n\n\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n}\n\n;","map":{"version":3,"sources":["C:/Users/Connor L/Documents/GitHub/mars/frontend/node_modules/http-proxy/lib/http-proxy/common.js"],"names":["common","exports","url","require","extend","_extend","required","upgradeHeader","isSSL","setupOutgoing","outgoing","options","req","forward","port","test","protocol","forEach","e","method","headers","auth","ca","rejectUnauthorized","secure","agent","localAddress","connection","target","targetPath","prependPath","path","outgoingPath","toProxy","parse","ignorePath","urlJoin","changeOrigin","host","hasPort","setupSocket","socket","setTimeout","setNoDelay","setKeepAlive","getPort","res","match","hasEncryptedConnection","Boolean","encrypted","pair","args","Array","prototype","slice","call","arguments","lastIndex","length","last","lastSegs","split","retSegs","shift","filter","join","replace","push","apply","rewriteCookieProperty","header","config","property","isArray","map","headerElement","RegExp","prefix","previousValue","newValue","indexOf"],"mappings":"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","sourcesContent":["var common   = exports,\r\n    url      = require('url'),\r\n    extend   = require('util')._extend,\r\n    required = require('requires-port');\r\n\r\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\r\n    isSSL = /^https|wss/;\r\n\r\n/**\r\n * Simple Regex for testing if protocol is https\r\n */\r\ncommon.isSSL = isSSL;\r\n/**\r\n * Copies the right headers from `options` and `req` to\r\n * `outgoing` which is then used to fire the proxied\r\n * request.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupOutgoing(outgoing, options, req)\r\n *    // => { host: ..., hostname: ...}\r\n *\r\n * @param {Object} Outgoing Base object to be filled with required properties\r\n * @param {Object} Options Config object passed to the proxy\r\n * @param {ClientRequest} Req Request Object\r\n * @param {String} Forward String to select forward or target\r\n * \r\n * @return {Object} Outgoing Object with all required properties set\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.setupOutgoing = function(outgoing, options, req, forward) {\r\n  outgoing.port = options[forward || 'target'].port ||\r\n                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\r\n\r\n  ['host', 'hostname', 'socketPath', 'pfx', 'key',\r\n    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(\r\n    function(e) { outgoing[e] = options[forward || 'target'][e]; }\r\n  );\r\n\r\n  outgoing.method = options.method || req.method;\r\n  outgoing.headers = extend({}, req.headers);\r\n\r\n  if (options.headers){\r\n    extend(outgoing.headers, options.headers);\r\n  }\r\n\r\n  if (options.auth) {\r\n    outgoing.auth = options.auth;\r\n  }\r\n  \r\n  if (options.ca) {\r\n      outgoing.ca = options.ca;\r\n  }\r\n\r\n  if (isSSL.test(options[forward || 'target'].protocol)) {\r\n    outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure;\r\n  }\r\n\r\n\r\n  outgoing.agent = options.agent || false;\r\n  outgoing.localAddress = options.localAddress;\r\n\r\n  //\r\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\r\n  // as node core doesn't handle this COMPLETELY properly yet.\r\n  //\r\n  if (!outgoing.agent) {\r\n    outgoing.headers = outgoing.headers || {};\r\n    if (typeof outgoing.headers.connection !== 'string'\r\n        || !upgradeHeader.test(outgoing.headers.connection)\r\n       ) { outgoing.headers.connection = 'close'; }\r\n  }\r\n\r\n\r\n  // the final path is target path + relative path requested by user:\r\n  var target = options[forward || 'target'];\r\n  var targetPath = target && options.prependPath !== false\r\n    ? (target.path || '')\r\n    : '';\r\n\r\n  //\r\n  // Remark: Can we somehow not use url.parse as a perf optimization?\r\n  //\r\n  var outgoingPath = !options.toProxy\r\n    ? (url.parse(req.url).path || '')\r\n    : req.url;\r\n\r\n  //\r\n  // Remark: ignorePath will just straight up ignore whatever the request's\r\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\r\n  // you are doing and are using conflicting options.\r\n  //\r\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\r\n\r\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\r\n\r\n  if (options.changeOrigin) {\r\n    outgoing.headers.host =\r\n      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)\r\n        ? outgoing.host + ':' + outgoing.port\r\n        : outgoing.host;\r\n  }\r\n  return outgoing;\r\n};\r\n\r\n/**\r\n * Set the proper configuration for sockets,\r\n * set no delay and set keep alive, also set\r\n * the timeout to 0.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupSocket(socket)\r\n *    // => Socket\r\n *\r\n * @param {Socket} Socket instance to setup\r\n * \r\n * @return {Socket} Return the configured socket.\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.setupSocket = function(socket) {\r\n  socket.setTimeout(0);\r\n  socket.setNoDelay(true);\r\n\r\n  socket.setKeepAlive(true, 0);\r\n\r\n  return socket;\r\n};\r\n\r\n/**\r\n * Get the port number from the host. Or guess it based on the connection type.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {String} The port number.\r\n *\r\n * @api private\r\n */\r\ncommon.getPort = function(req) {\r\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\r\n\r\n  return res ?\r\n    res[1] :\r\n    common.hasEncryptedConnection(req) ? '443' : '80';\r\n};\r\n\r\n/**\r\n * Check if the request has an encrypted connection.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {Boolean} Whether the connection is encrypted or not.\r\n *\r\n * @api private\r\n */\r\ncommon.hasEncryptedConnection = function(req) {\r\n  return Boolean(req.connection.encrypted || req.connection.pair);\r\n};\r\n\r\n/**\r\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\r\n *\r\n * @return {String} The generated path.\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.urlJoin = function() {\r\n    //\r\n    // We do not want to mess with the query string. All we want to touch is the path.\r\n    //\r\n  var args = Array.prototype.slice.call(arguments),\r\n      lastIndex = args.length - 1,\r\n      last = args[lastIndex],\r\n      lastSegs = last.split('?'),\r\n      retSegs;\r\n\r\n  args[lastIndex] = lastSegs.shift();\r\n\r\n  //\r\n  // Join all strings, but remove empty strings so we don't get extra slashes from\r\n  // joining e.g. ['', 'am']\r\n  //\r\n  retSegs = [\r\n    args.filter(Boolean).join('/')\r\n        .replace(/\\/+/g, '/')\r\n        .replace('http:/', 'http://')\r\n        .replace('https:/', 'https://')\r\n  ];\r\n\r\n  // Only join the query string if it exists so we don't have trailing a '?'\r\n  // on every request\r\n\r\n  // Handle case where there could be multiple ? in the URL.\r\n  retSegs.push.apply(retSegs, lastSegs);\r\n\r\n  return retSegs.join('?')\r\n};\r\n\r\n/**\r\n * Rewrites or removes the domain of a cookie header\r\n *\r\n * @param {String|Array} Header\r\n * @param {Object} Config, mapping of domain to rewritten domain.\r\n *                 '*' key to match any domain, null value to remove the domain.\r\n *\r\n * @api private\r\n */\r\ncommon.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {\r\n  if (Array.isArray(header)) {\r\n    return header.map(function (headerElement) {\r\n      return rewriteCookieProperty(headerElement, config, property);\r\n    });\r\n  }\r\n  return header.replace(new RegExp(\"(;\\\\s*\" + property + \"=)([^;]+)\", 'i'), function(match, prefix, previousValue) {\r\n    var newValue;\r\n    if (previousValue in config) {\r\n      newValue = config[previousValue];\r\n    } else if ('*' in config) {\r\n      newValue = config['*'];\r\n    } else {\r\n      //no match, return previous value\r\n      return match;\r\n    }\r\n    if (newValue) {\r\n      //replace value\r\n      return prefix + newValue;\r\n    } else {\r\n      //remove value\r\n      return '';\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Check the host and see if it potentially has a port in it (keep it simple)\r\n *\r\n * @returns {Boolean} Whether we have one or not\r\n *\r\n * @api private\r\n */\r\nfunction hasPort(host) {\r\n  return !!~host.indexOf(':');\r\n};\r\n"]},"metadata":{},"sourceType":"script"}