{"ast":null,"code":"var httpNative = require('http'),\n    httpsNative = require('https'),\n    web_o = require('./web-outgoing'),\n    common = require('../common'),\n    followRedirects = require('follow-redirects');\n\nweb_o = Object.keys(web_o).map(function (pass) {\n  return web_o[pass];\n});\nvar nativeAgents = {\n  http: httpNative,\n  https: httpsNative\n};\n/*!\r\n * Array of passes.\r\n *\r\n * A `pass` is just a function that is executed on `req, res, options`\r\n * so that you can easily add new checks while still keeping the base\r\n * flexible.\r\n */\n\nmodule.exports = {\n  /**\r\n   * Sets `content-length` to '0' if request is of DELETE type.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n  deleteLength: function deleteLength(req, res, options) {\n    if ((req.method === 'DELETE' || req.method === 'OPTIONS') && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n      delete req.headers['transfer-encoding'];\n    }\n  },\n\n  /**\r\n   * Sets timeout in request socket if it was specified in options.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n  timeout: function timeout(req, res, options) {\n    if (options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\r\n   * Sets `x-forwarded-*` headers if specified in config.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n  XHeaders: function XHeaders(req, res, options) {\n    if (!options.xfwd) return;\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n    req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';\n  },\n\n  /**\r\n   * Does the actual proxying. If `forward` is enabled fires up\r\n   * a ForwardStream, same happens for ProxyStream. The request\r\n   * just dies otherwise.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n  stream: function stream(req, res, options, _, server, clb) {\n    // And we begin!\n    server.emit('start', req, res, options.target || options.forward);\n    var agents = options.followRedirects ? followRedirects : nativeAgents;\n    var http = agents.http;\n    var https = agents.https;\n\n    if (options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req, 'forward')); // error handler (e.g. ECONNRESET, ECONNREFUSED)\n      // Handle errors on incoming request as well as it makes sense to\n\n      var forwardError = createErrorHandler(forwardReq, options.forward);\n      req.on('error', forwardError);\n      forwardReq.on('error', forwardError);\n      (options.buffer || req).pipe(forwardReq);\n\n      if (!options.target) {\n        return res.end();\n      }\n    } // Request initalization\n\n\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n    proxyReq.on('socket', function (socket) {\n      if (server && !proxyReq.getHeader('expect')) {\n        server.emit('proxyReq', proxyReq, req, res, options);\n      }\n    }); // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n\n    if (options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function () {\n        proxyReq.abort();\n      });\n    } // Ensure we abort proxy if request is aborted\n\n\n    req.on('aborted', function () {\n      proxyReq.abort();\n    }); // handle errors in proxy and incoming request, just like for forward proxy\n\n    var proxyError = createErrorHandler(proxyReq, options.target);\n    req.on('error', proxyError);\n    proxyReq.on('error', proxyError);\n\n    function createErrorHandler(proxyReq, url) {\n      return function proxyError(err) {\n        if (req.socket.destroyed && err.code === 'ECONNRESET') {\n          server.emit('econnreset', err, req, res, url);\n          return proxyReq.abort();\n        }\n\n        if (clb) {\n          clb(err, req, res, url);\n        } else {\n          server.emit('error', err, req, res, url);\n        }\n      };\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n    proxyReq.on('response', function (proxyRes) {\n      if (server) {\n        server.emit('proxyRes', proxyRes, req, res);\n      }\n\n      if (!res.headersSent && !options.selfHandleResponse) {\n        for (var i = 0; i < web_o.length; i++) {\n          if (web_o[i](req, res, proxyRes, options)) {\n            break;\n          }\n        }\n      }\n\n      if (!res.finished) {\n        // Allow us to listen when the proxy has completed\n        proxyRes.on('end', function () {\n          if (server) server.emit('end', req, res, proxyRes);\n        }); // We pipe to the response unless its expected to be handled by the user\n\n        if (!options.selfHandleResponse) proxyRes.pipe(res);\n      } else {\n        if (server) server.emit('end', req, res, proxyRes);\n      }\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/Connor L/Documents/GitHub/mars/frontend/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js"],"names":["httpNative","require","httpsNative","web_o","common","followRedirects","Object","keys","map","pass","nativeAgents","http","https","module","exports","deleteLength","req","res","options","method","headers","timeout","socket","setTimeout","XHeaders","xfwd","encrypted","isSpdy","hasEncryptedConnection","values","for","connection","remoteAddress","port","getPort","proto","forEach","header","stream","_","server","clb","emit","target","forward","agents","forwardReq","protocol","request","setupOutgoing","ssl","forwardError","createErrorHandler","on","buffer","pipe","end","proxyReq","getHeader","proxyTimeout","abort","proxyError","url","err","destroyed","code","proxyRes","headersSent","selfHandleResponse","i","length","finished"],"mappings":"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","sourcesContent":["var httpNative   = require('http'),\r\n    httpsNative  = require('https'),\r\n    web_o  = require('./web-outgoing'),\r\n    common = require('../common'),\r\n    followRedirects = require('follow-redirects');\r\n\r\nweb_o = Object.keys(web_o).map(function(pass) {\r\n  return web_o[pass];\r\n});\r\n\r\nvar nativeAgents = { http: httpNative, https: httpsNative };\r\n\r\n/*!\r\n * Array of passes.\r\n *\r\n * A `pass` is just a function that is executed on `req, res, options`\r\n * so that you can easily add new checks while still keeping the base\r\n * flexible.\r\n */\r\n\r\n\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Sets `content-length` to '0' if request is of DELETE type.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  deleteLength: function deleteLength(req, res, options) {\r\n    if((req.method === 'DELETE' || req.method === 'OPTIONS')\r\n       && !req.headers['content-length']) {\r\n      req.headers['content-length'] = '0';\r\n      delete req.headers['transfer-encoding'];\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets timeout in request socket if it was specified in options.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  timeout: function timeout(req, res, options) {\r\n    if(options.timeout) {\r\n      req.socket.setTimeout(options.timeout);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets `x-forwarded-*` headers if specified in config.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHeaders: function XHeaders(req, res, options) {\r\n    if(!options.xfwd) return;\r\n\r\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\r\n    var values = {\r\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\r\n      port : common.getPort(req),\r\n      proto: encrypted ? 'https' : 'http'\r\n    };\r\n\r\n    ['for', 'port', 'proto'].forEach(function(header) {\r\n      req.headers['x-forwarded-' + header] =\r\n        (req.headers['x-forwarded-' + header] || '') +\r\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\r\n        values[header];\r\n    });\r\n\r\n    req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';\r\n  },\r\n\r\n  /**\r\n   * Does the actual proxying. If `forward` is enabled fires up\r\n   * a ForwardStream, same happens for ProxyStream. The request\r\n   * just dies otherwise.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {IncomingMessage} Res Response object\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  stream: function stream(req, res, options, _, server, clb) {\r\n\r\n    // And we begin!\r\n    server.emit('start', req, res, options.target || options.forward);\r\n\r\n    var agents = options.followRedirects ? followRedirects : nativeAgents;\r\n    var http = agents.http;\r\n    var https = agents.https;\r\n\r\n    if(options.forward) {\r\n      // If forward enable, so just pipe the request\r\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(\r\n        common.setupOutgoing(options.ssl || {}, options, req, 'forward')\r\n      );\r\n\r\n      // error handler (e.g. ECONNRESET, ECONNREFUSED)\r\n      // Handle errors on incoming request as well as it makes sense to\r\n      var forwardError = createErrorHandler(forwardReq, options.forward);\r\n      req.on('error', forwardError);\r\n      forwardReq.on('error', forwardError);\r\n\r\n      (options.buffer || req).pipe(forwardReq);\r\n      if(!options.target) { return res.end(); }\r\n    }\r\n\r\n    // Request initalization\r\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(\r\n      common.setupOutgoing(options.ssl || {}, options, req)\r\n    );\r\n\r\n    // Enable developers to modify the proxyReq before headers are sent\r\n    proxyReq.on('socket', function(socket) {\r\n      if(server && !proxyReq.getHeader('expect')) {\r\n        server.emit('proxyReq', proxyReq, req, res, options);\r\n      }\r\n    });\r\n\r\n    // allow outgoing socket to timeout so that we could\r\n    // show an error page at the initial request\r\n    if(options.proxyTimeout) {\r\n      proxyReq.setTimeout(options.proxyTimeout, function() {\r\n         proxyReq.abort();\r\n      });\r\n    }\r\n\r\n    // Ensure we abort proxy if request is aborted\r\n    req.on('aborted', function () {\r\n      proxyReq.abort();\r\n    });\r\n\r\n    // handle errors in proxy and incoming request, just like for forward proxy\r\n    var proxyError = createErrorHandler(proxyReq, options.target);\r\n    req.on('error', proxyError);\r\n    proxyReq.on('error', proxyError);\r\n\r\n    function createErrorHandler(proxyReq, url) {\r\n      return function proxyError(err) {\r\n        if (req.socket.destroyed && err.code === 'ECONNRESET') {\r\n          server.emit('econnreset', err, req, res, url);\r\n          return proxyReq.abort();\r\n        }\r\n\r\n        if (clb) {\r\n          clb(err, req, res, url);\r\n        } else {\r\n          server.emit('error', err, req, res, url);\r\n        }\r\n      }\r\n    }\r\n\r\n    (options.buffer || req).pipe(proxyReq);\r\n\r\n    proxyReq.on('response', function(proxyRes) {\r\n      if(server) { server.emit('proxyRes', proxyRes, req, res); }\r\n\r\n      if(!res.headersSent && !options.selfHandleResponse) {\r\n        for(var i=0; i < web_o.length; i++) {\r\n          if(web_o[i](req, res, proxyRes, options)) { break; }\r\n        }\r\n      }\r\n\r\n      if (!res.finished) {\r\n        // Allow us to listen when the proxy has completed\r\n        proxyRes.on('end', function () {\r\n          if (server) server.emit('end', req, res, proxyRes);\r\n        });\r\n        // We pipe to the response unless its expected to be handled by the user\r\n        if (!options.selfHandleResponse) proxyRes.pipe(res);\r\n      } else {\r\n        if (server) server.emit('end', req, res, proxyRes);\r\n      }\r\n    });\r\n  }\r\n\r\n};\r\n"]},"metadata":{},"sourceType":"script"}